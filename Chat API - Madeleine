# Chat backend
# Stores messages in XML, lets us send/get/edit/delete chats

import xml.etree.ElementTree as ET
from pathlib import Path
import time

class ChatBackend:
    def __init__(self, file_name="messages.xml"):
        self.chat_file = Path(file_name)
        self.demo_bot = False
        self.make_sure_file_exists()

    def send_message(self, contact_name, sender, text):
        contact_name = (contact_name or "").strip()
        text = (text or "").strip()
        sender = (sender or "You").strip()

        if not contact_name or not text:
            print("missing contact or text")
            return None

        tree, root = self.get_tree()
        contact = self.find_or_create_contact(root, contact_name)

        ts = int(time.time())
        msg = ET.SubElement(contact, "message", {"sender": sender, "ts": str(ts)})
        msg.text = text
        self.save_tree(tree)
        print("saved message:", text)

        if self.demo_bot and sender.lower() != "bot":
            self.bot_reply(contact, text)
            self.save_tree(tree)

        return {"contact": contact_name, "sender": sender, "text": text, "ts": ts}

    def get_messages(self, contact_name, limit=None):
        contact_name = (contact_name or "").strip()
        if not contact_name or not self.chat_file.exists():
            return []

        root = self.get_root()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return []

        data = []
        for m in contact.findall("message"):
            item = {
                "sender": m.get("sender", "You"),
                "text": m.text or "",
                "ts": self.safe_int(m.get("ts", "0")),
            }
            data.append(item)

        data.sort(key=lambda x: x["ts"])
        if isinstance(limit, int) and limit > 0:
            data = data[-limit:]
        return data

    def delete_history(self, contact_name):
        contact_name = (contact_name or "").strip()
        if not contact_name:
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        root.remove(contact)
        self.save_tree(tree)
        print("deleted history for", contact_name)
        return True

    def search_messages(self, contact_name, keyword, limit=None):
        keyword = (keyword or "").strip().lower()
        if not keyword:
            return []

        found = [m for m in self.get_messages(contact_name) if keyword in m["text"].lower()]
        if isinstance(limit, int) and limit > 0:
            found = found[-limit:]
        return found

    def edit_message(self, contact_name, ts, new_text):
        new_text = (new_text or "").strip()
        if not contact_name or not isinstance(ts, int) or not new_text:
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        for m in contact.findall("message"):
            if self.safe_int(m.get("ts")) == ts:
                m.text = new_text
                self.save_tree(tree)
                print("edited message")
                return True
        return False

    def delete_message(self, contact_name, ts):
        if not contact_name or not isinstance(ts, int):
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        for m in contact.findall("message"):
            if self.safe_int(m.get("ts")) == ts:
                contact.remove(m)
                self.save_tree(tree)
                print("ğŸ—‘ï¸ deleted one message")
                return True
        return False

    def enable_bot(self, on=True):
        self.demo_bot = bool(on)
        print("demo bot on" if on else "demo bot off")

    def readable_time(self, ts):
        try:
            t = time.localtime(ts)
            return f"{t.tm_year}-{t.tm_mon:02}-{t.tm_mday:02} {t.tm_hour:02}:{t.tm_min:02}"
        except:
            return "unknown"

    # helpers

    def make_sure_file_exists(self):
        if not self.chat_file.exists():
            root = ET.Element("chats")
            ET.ElementTree(root).write(self.chat_file, encoding="utf-8", xml_declaration=True)

    def get_root(self):
        try:
            return ET.parse(self.chat_file).getroot()
        except:
            self.make_sure_file_exists()
            return ET.parse(self.chat_file).getroot()

    def get_tree(self):
        try:
            tree = ET.parse(self.chat_file)
            return tree, tree.getroot()
        except:
            self.make_sure_file_exists()
            tree = ET.parse(self.chat_file)
            return tree, tree.getroot()

    def save_tree(self, tree):
        tree.write(self.chat_file, encoding="utf-8", xml_declaration=True)

    def find_contact(self, root, name):
        for c in root.findall("contact"):
            if c.get("name") == name:
                return c
        return None

    def find_or_create_contact(self, root, name):
        found = self.find_contact(root, name)
        if found is not None:
            return found
        return ET.SubElement(root, "contact", {"name": name})

    def get_gemini_translation(self, text, target_lang="fr"):
        """
        Placeholder function!!
        Later, this will call Gemini AI to translate text into our desired language
        """
        # prompt the translation
        if target_lang == "fr":
            return f"(franÃ§ais simulÃ©) {text}"
        else:
            return f"(english simulated) {text}"

  def bot_reply(self, contact, text):
        user_text = text.lower()
        ts = int(time.time())

        if any(word in user_text for word in ["hello", "hi", "hey", "bonjour"]):
            reply = "Salut ! Comment tu vas aujourdâ€™hui ?"

        elif "how are you" in user_text or "Ã§a va" in user_text:
            reply = "Je vais bien, merci. Et toi ?"

        elif user_text.startswith("translate"):
            phrase = text.split("translate", 1)[1].strip()
            if phrase:
                # Not actual translation, just set up for Gemini later
                reply = f"En franÃ§ais, tu dirais : Â« {phrase} Â» ğŸ‡«ğŸ‡·"
            else:
                reply = "Tu veux que je traduise quoi ?"

        elif "food" in user_text or "eat" in user_text:
            reply = "Miam, la nourriture franÃ§aise est la meilleure ! Tu veux apprendre des mots sur la cuisine ?"

        elif "weather" in user_text:
            reply = "Il fait toujours beau quand on parle franÃ§ais"

        elif "thank" in user_text or "merci" in user_text:
            reply = "De rien. Câ€™est toujours un plaisir de tâ€™aider."

        elif "bye" in user_text or "goodbye" in user_text or "au revoir" in user_text:
            reply = "Ã€ bientÃ´t. Continue Ã  pratiquer ton franÃ§ais !"

        else:
            reply = f"Je ne comprends pas encore Â« {text} Â», mais jâ€™apprends !"

        bot_msg = ET.SubElement(contact, "message", {"sender": "Bot", "ts": str(ts)})
        bot_msg.text = reply

    def safe_int(self, val, default=0):
        try:
            return int(val)
        except:
            return default

