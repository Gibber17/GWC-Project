# Chat backend for language app
# Stores messages in XML, lets us send/get/edit/delete chats

import xml.etree.ElementTree as ET
from pathlib import Path
import time


class ChatBackend:
    def __init__(self, file_name="messages.xml"):
        self.chat_file = Path(file_name)
        self.demo_bot = False
        self.make_sure_file_exists()

    # send a message and save it
    def send_message(self, contact_name, sender, text):
        contact_name = (contact_name or "").strip()
        text = (text or "").strip()
        sender = (sender or "You").strip()

        if not contact_name or not text:
            print("‚ö†Ô∏è missing contact or text")
            return None

        tree, root = self.get_tree()
        contact = self.find_or_create_contact(root, contact_name)

        ts = int(time.time())
        msg = ET.SubElement(contact, "message", {"sender": sender, "ts": str(ts)})
        msg.text = text
        self.save_tree(tree)
        print("üíæ saved message:", text)

        # if bot is on, auto reply
        if self.demo_bot and sender.lower() != "bot":
            self.bot_reply(contact, text)
            self.save_tree(tree)

        return {"contact": contact_name, "sender": sender, "text": text, "ts": ts}

    # get all messages for one contact
    def get_messages(self, contact_name, limit=None):
        contact_name = (contact_name or "").strip()
        if not contact_name or not self.chat_file.exists():
            return []

        root = self.get_root()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return []

        data = []
        for m in contact.findall("message"):
            item = {
                "sender": m.get("sender", "You"),
                "text": m.text or "",
                "ts": self.safe_int(m.get("ts", "0")),
            }
            data.append(item)

        data.sort(key=lambda x: x["ts"])
        if isinstance(limit, int) and limit > 0:
            data = data[-limit:]
        return data

    # delete all messages for one contact
    def delete_history(self, contact_name):
        contact_name = (contact_name or "").strip()
        if not contact_name:
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        root.remove(contact)
        self.save_tree(tree)
        print("üóëÔ∏è deleted history for", contact_name)
        return True

    # search chat for a keyword
    def search_messages(self, contact_name, keyword, limit=None):
        keyword = (keyword or "").strip().lower()
        if not keyword:
            return []

        found = [m for m in self.get_messages(contact_name) if keyword in m["text"].lower()]
        if isinstance(limit, int) and limit > 0:
            found = found[-limit:]
        return found

    # edit one message
    def edit_message(self, contact_name, ts, new_text):
        new_text = (new_text or "").strip()
        if not contact_name or not isinstance(ts, int) or not new_text:
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        for m in contact.findall("message"):
            if self.safe_int(m.get("ts")) == ts:
                m.text = new_text
                self.save_tree(tree)
                print("‚úèÔ∏è edited message")
                return True
        return False

    # delete one message by timestamp
    def delete_message(self, contact_name, ts):
        if not contact_name or not isinstance(ts, int):
            return False

        tree, root = self.get_tree()
        contact = self.find_contact(root, contact_name)
        if contact is None:
            return False

        for m in contact.findall("message"):
            if self.safe_int(m.get("ts")) == ts:
                contact.remove(m)
                self.save_tree(tree)
                print("üóëÔ∏è deleted one message")
                return True
        return False

    # turn the demo bot on/off
    def enable_bot(self, on=True):
        self.demo_bot = bool(on)
        print("ü§ñ demo bot on" if on else "demo bot off")

    # format the time so it‚Äôs readable
    def readable_time(self, ts):
        try:
            t = time.localtime(ts)
            return f"{t.tm_year}-{t.tm_mon:02}-{t.tm_mday:02} {t.tm_hour:02}:{t.tm_min:02}"
        except:
            return "unknown"

    # helpers below

    def make_sure_file_exists(self):
        if not self.chat_file.exists():
            root = ET.Element("chats")
            ET.ElementTree(root).write(self.chat_file, encoding="utf-8", xml_declaration=True)

    def get_root(self):
        try:
            return ET.parse(self.chat_file).getroot()
        except:
            self.make_sure_file_exists()
            return ET.parse(self.chat_file).getroot()

    def get_tree(self):
        try:
            tree = ET.parse(self.chat_file)
            return tree, tree.getroot()
        except:
            self.make_sure_file_exists()
            tree = ET.parse(self.chat_file)
            return tree, tree.getroot()

    def save_tree(self, tree):
        tree.write(self.chat_file, encoding="utf-8", xml_declaration=True)

    def find_contact(self, root, name):
        for c in root.findall("contact"):
            if c.get("name") == name:
                return c
        return None

    def find_or_create_contact(self, root, name):
        found = self.find_contact(root, name)
        if found is not None:
            return found
        return ET.SubElement(root, "contact", {"name": name})

    def bot_reply(self, contact, text):
        reply = "Bonjour! üëã" if "hello" in text.lower() else f"I heard: {text}"
        ts = int(time.time())
        bot_msg = ET.SubElement(contact, "message", {"sender": "Bot", "ts": str(ts)})
        bot_msg.text = reply

    def safe_int(self, val, default=0):
        try:
            return int(val)
        except:
            return default
